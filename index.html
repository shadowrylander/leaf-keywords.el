<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-14 Mon 10:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="conao3" />
<link rel="stylesheet" type="text/css" href="https://combinatronics.io/sylvorg/settings/main/src/styles/primary/syvl.css" />
<link rel="icon" href="https://combinatronics.io/sylvorg/settings/main/src/icons/favicons/shiny-zigzagoon-galar.ico" sizes="any" />
<link rel="icon" href="https://combinatronics.io/sylvorg/settings/main/src/icons/favicons/shiny-zigzagoon-galar.svg" />
<link rel="manifest" href="https://combinatronics.io/sylvorg/settings/main/manifest.json" />
<link rel="stylesheet" type="text/css" href="https://combinatronics.io/sylvorg/settings/main/src/styles/highlight/paraiso-dark.min.css" />
<script src="https://combinatronics.io/sylvorg/settings/main/src/scripts/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<div class="header">
<h1>We Are Syvlorg.</h1>
<a href="">About Me</a>
<a href="">About This Website</a>
<a href="">About Syvlorg</a>
<a href="https://resume.syvl.org">Résumé</a>
<a href="https://index.syvl.org">Index</a>
</div>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5%",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0128418">Table of Contents</a></li>
<li><a href="#orga082845">Description</a></li>
<li><a href="#org02aba2d">Install</a>
<ul>
<li><a href="#orga4cbf8a">MELPA</a></li>
<li><a href="#orgdea70af">Manual install</a></li>
</ul>
</li>
<li><a href="#org8cb57ff">Usage</a></li>
<li><a href="#org30035f2">Ensure keywords</a>
<ul>
<li><a href="#orgf376f1b">:package, :ensure keywords</a></li>
<li><a href="#org76a24df">:feather keyword</a></li>
<li><a href="#orgc26ef3d">:el-get keyword</a></li>
<li><a href="#org8dc50f6">:straight keyword</a></li>
<li><a href="#orgef4bd83">:ensure-system-package keyword</a></li>
</ul>
</li>
<li><a href="#orgf307bbd">Bind keywords</a>
<ul>
<li><a href="#orgbc4092e">:bind :bind* keywords</a></li>
<li><a href="#org620bbc6">:hydra, :mode-hydra, :pretty-hydra keyword</a></li>
<li><a href="#org9e9b615">:transient keyword</a></li>
<li><a href="#orga47b812">:chord :chord* keywords</a></li>
<li><a href="#org2f3abfa">:smartrep, :smartrep* keywords</a></li>
<li><a href="#org37d7e1a">:combo, :combo* keywords</a></li>
<li><a href="#org715ef6b">:mode-hook keyword</a></li>
</ul>
</li>
<li><a href="#org6d0d37d">Modeline keywords</a>
<ul>
<li><a href="#org9ac8558">:blackout keyword</a></li>
<li><a href="#org9487779">:diminish keyword</a></li>
<li><a href="#orgdcd9394">:delight keyword</a></li>
</ul>
</li>
<li><a href="#org8044adb">Misc keywords</a>
<ul>
<li><a href="#org26a10c6">:grugru keyword</a></li>
<li><a href="#org3351a3b">:defaults keyword</a></li>
</ul>
</li>
<li><a href="#org95b57a9">Information</a>
<ul>
<li><a href="#org1963b1c">Donation</a></li>
<li><a href="#orga69c6f5">Community</a></li>
<li><a href="#org576d9e4">Contribution</a>
<ul>
<li><a href="#org5fffa03">Define new keywords</a></li>
</ul>
</li>
<li><a href="#org4a815ea">Migration</a>
<ul>
<li><a href="#org219a9d5">leaf-keywords v1.0 to v2.0</a></li>
</ul>
</li>
<li><a href="#org479ad4b">License</a></li>
<li><a href="#org494a454">Author</a></li>
<li><a href="#org9c8ff34">Contributors</a></li>
<li><a href="#orgce945b5">Special Thanks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="https://github.com/conao3/leaf-keywords.el"><img src="https://raw.githubusercontent.com/conao3/files/master/blob/headers/png/leaf-keywords.el.png" alt="leaf-keywords.el.png" /></a>
<a href="https://github.com/conao3/leaf-keywords.el/blob/master/LICENSE"><img src="https://img.shields.io/github/license/conao3/leaf-keywords.el.svg?style=flat-square" alt="leaf-keywords.el.svg?style=flat-square" /></a>
<a href="https://github.com/conao3/leaf-keywords.el/releases"><img src="https://img.shields.io/github/tag/conao3/leaf-keywords.el.svg?style=flat-square" alt="leaf-keywords.el.svg?style=flat-square" /></a>
<a href="https://github.com/conao3/leaf-keywords.el/actions"><object type="image/svg+xml" data="https://github.com/conao3/leaf-keywords.el/workflows/Main%20workflow/badge.svg" class="org-svg">
Sorry, your browser does not support SVG.</object></a>
<a href="https://app.codacy.com/project/conao3/leaf-keywords.el/dashboard"><img src="https://img.shields.io/codacy/grade/f3075770da434fbbb900e88e25af80dd.svg?logo=codacy&amp;style=flat-square" alt="f3075770da434fbbb900e88e25af80dd.svg?logo=codacy&amp;style=flat-square" /></a>
<a href="https://www.patreon.com/conao3"><img src="https://img.shields.io/badge/patreon-become%20a%20patron-orange.svg?logo=patreon&amp;style=flat-square" alt="patreon-become%20a%20patron-orange.svg?logo=patreon&amp;style=flat-square" /></a>
<a href="https://twitter.com/conao_3"><img src="https://img.shields.io/badge/twitter-@conao__3-blue.svg?logo=twitter&amp;style=flat-square" alt="twitter-@conao__3-blue.svg?logo=twitter&amp;style=flat-square" /></a>
<a href="https://join.slack.com/t/conao3-support/shared_invite/enQtNjUzMDMxODcyMjE1LTA4ZGRmOWYwZWE3NmE5NTkyZjk3M2JhYzU2ZmRkMzdiMDdlYTQ0ODMyM2ExOGY0OTkzMzZiMTNmZjJjY2I5NTM"><img src="https://img.shields.io/badge/chat-on_slack-blue.svg?logo=slack&amp;style=flat-square" alt="chat-on_slack-blue.svg?logo=slack&amp;style=flat-square" /></a>
<a href="https://melpa.org/#/leaf-keywords"><object type="image/svg+xml" data="https://melpa.org/packages/leaf-keywords-badge.svg" class="org-svg">
Sorry, your browser does not support SVG.</object></a>
<a href="https://stable.melpa.org/#/leaf-keywords"><object type="image/svg+xml" data="https://stable.melpa.org/packages/leaf-keywords-badge.svg" class="org-svg">
Sorry, your browser does not support SVG.</object></a>
</p>

<div id="outline-container-org0128418" class="outline-2">
<h2 id="org0128418">Table of Contents</h2>
<div class="outline-text-2" id="text-org0128418">
<ul class="org-ul">
<li><a href="#orga082845">Description</a></li>
<li><a href="#org02aba2d">Install</a>
<ul class="org-ul">
<li><a href="#orga4cbf8a">MELPA</a></li>
<li><a href="#orgdea70af">Manual install</a></li>
</ul></li>
<li><a href="#org8cb57ff">Usage</a></li>
<li><a href="#org30035f2">Ensure keywords</a>
<ul class="org-ul">
<li><a href="#orgf376f1b">:package, :ensure keywords</a></li>
<li><a href="#org76a24df">:feather keyword</a></li>
<li><a href="#orgc26ef3d">:el-get keyword</a></li>
<li><a href="#org8dc50f6">:straight keyword</a></li>
<li><a href="#orgef4bd83">:ensure-system-package keyword</a></li>
</ul></li>
<li><a href="#orgf307bbd">Bind keywords</a>
<ul class="org-ul">
<li><a href="#org620bbc6">:hydra, :mode-hydra, :pretty-hydra keyword</a></li>
<li><a href="#org9e9b615">:transient keyword</a></li>
<li><a href="#org715ef6b">:mode-hook keyword</a></li>
</ul></li>
<li><a href="#org6d0d37d">Modeline keywords</a>
<ul class="org-ul">
<li><a href="#org9ac8558">:blackout keyword</a></li>
<li><a href="#org9487779">:diminish keyword</a></li>
<li><a href="#orgdcd9394">:delight keyword</a></li>
</ul></li>
<li><a href="#org8044adb">Misc keywords</a>
<ul class="org-ul">
<li><a href="#org26a10c6">:grugru keyword</a></li>
<li><a href="#org3351a3b">:defaults keyword</a></li>
</ul></li>
<li><a href="#org95b57a9">Information</a>
<ul class="org-ul">
<li><a href="#org1963b1c">Donation</a></li>
<li><a href="#orga69c6f5">Community</a></li>
<li><a href="#org576d9e4">Contribution</a>
<ul class="org-ul">
<li><a href="#org5fffa03">Define new keywords</a></li>
</ul></li>
<li><a href="#org4a815ea">Migration</a></li>
<li><a href="#org479ad4b">License</a></li>
<li><a href="#org494a454">Author</a></li>
<li><a href="#org9c8ff34">Contributors</a></li>
<li><a href="#orgce945b5">Special Thanks</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orga082845" class="outline-2">
<h2 id="orga082845">Description</h2>
<div class="outline-text-2" id="text-orga082845">
<p>
<code>leaf.el</code> is yet another <a href="https://github.com/jwiegley/use-package">use-package</a>.
</p>

<p>
<code>leaf-keywords.el</code> add additional keywords for <a href="https://github.com/conao3/leaf.el">leaf.el</a>.
</p>
</div>
</div>

<div id="outline-container-org02aba2d" class="outline-2">
<h2 id="org02aba2d">Install</h2>
<div class="outline-text-2" id="text-org02aba2d">
</div>
<div id="outline-container-orga4cbf8a" class="outline-3">
<h3 id="orga4cbf8a">MELPA</h3>
<div class="outline-text-3" id="text-orga4cbf8a">
<p>
<code>leaf.el</code> and <code>leaf-keywords.el</code> can install with package.el from MELPA, so sample instration code is below.
</p>

<p>
In order to work from Emacs-22, the package manager and the key binding manager
that accompanies <code>leaf</code> must also be developed with the assumption that they will work from Emacs-22.
</p>

<p>
I have plans to develop it, but it's not finished yet.
</p>

<p>
Package to be developed
</p>
<ul class="org-ul">
<li><a href="https://github.com/conao3/feather.el">feather.el</a> instead of <code>package.el</code></li>
<li>leaf-key.el instead of <code>bind-key</code> -&gt; (Achieved! Now <code>leaf</code> builtin)</li>
</ul>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (prog1 "prepare leaf"
    (prog1 "package"
      (custom-set-variables
       '(package-archives '(("org"   . "https://orgmode.org/elpa/")
                            ("melpa" . "https://melpa.org/packages/")
                            ("gnu"   . "https://elpa.gnu.org/packages/"))))
      (package-initialize))

    (prog1 "leaf"
      (unless (package-installed-p 'leaf)
        (unless (assoc 'leaf package-archive-contents)
          (package-refresh-contents))
        (condition-case err
            (package-install 'leaf)
          (error
           (package-refresh-contents)       ; renew local melpa cache if fail
           (package-install 'leaf))))

      (leaf leaf-keywords
        :ensure t
        :config (leaf-keywords-init)))

    (prog1 "optional packages for leaf-keywords"
      ;; optional packages if you want to use :hydra, :el-get,,,
      (leaf hydra :ensure t)
      (leaf el-get :ensure t
        :custom ((el-get-git-shallow-clone  . t)))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgdea70af" class="outline-3">
<h3 id="orgdea70af">Manual install</h3>
<div class="outline-text-3" id="text-orgdea70af">
<p>
Put <code>leaf.el</code> at any folder added <code>load-path</code>.
Then <code>(require 'leaf)</code> and use like <code>use-pacakge</code>.
</p>

<p>
(In this example, you installed/loaded leaf directly, so you can configure <code>package.el</code> using <code>leaf</code>.)
</p>
<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  ;; add to load-path
  ;; (locate-user-emacs-file "site-lisp/leaf.el")
  ;;  =&gt; "~/.emacs.d/local/26.1/site-lisp/leaf.el"

  (prog1 "leaf"
    (add-to-list 'load-path (locate-user-emacs-file "site-lisp/leaf.el"))
    (require 'leaf)
    
    (leaf package
        :custom ((package-archives . '(("org"   . "https://orgmode.org/elpa/")
                                       ("melpa" . "https://melpa.org/packages/")
                                       ("gnu"   . "https://elpa.gnu.org/packages/"))))
        :config
        (package-initialize))

    (leaf leaf-keywords
      :ensure t
      :config (leaf-keywords-init))

    (prog1 "optional packages for leaf-keywords"
      ;; optional packages if you want to use :hydra, :el-get,,,
      (leaf hydra :ensure t)
      (leaf el-get :ensure t
        :custom ((el-get-git-shallow-clone  . t)))))
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8cb57ff" class="outline-2">
<h2 id="org8cb57ff">Usage</h2>
<div class="outline-text-2" id="text-org8cb57ff">
<p>
Use <code>leaf</code> in your init.el like <code>use-package</code>.
You declaratively tell the <code>leaf</code> to configure the package using special keywords.
</p>

<p>
<code>leaf</code> converts your declaration into Elisp for Emacs to understand, and Emacs executes it to configure the package.
</p>
</div>
</div>

<div id="outline-container-org30035f2" class="outline-2">
<h2 id="org30035f2">Ensure keywords</h2>
<div class="outline-text-2" id="text-org30035f2">
</div>
<div id="outline-container-orgf376f1b" class="outline-3">
<h3 id="orgf376f1b">:package, :ensure keywords</h3>
<div class="outline-text-3" id="text-orgf376f1b">
<p>
These keywords are buildin. Info is <a href="https://github.com/conao3/leaf.el#package-ensure-keywords">here</a>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/package
    '(((leaf leaf
         :package t
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-init)))

      ((leaf leaf
         :package t leaf-browser
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-handler-package leaf leaf-browser nil)
         (leaf-init)))

      ((leaf leaf
         :package feather leaf-key leaf-browser
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf feather nil)
         (leaf-handler-package leaf leaf-key nil)
         (leaf-handler-package leaf leaf-browser nil)
         (leaf-init)))))

  (cort-deftest-with-macroexpand leaf/handler-package
    '(((leaf macrostep :ensure t)
       (prog1 'macrostep
         (leaf-handler-package macrostep macrostep nil))

       ((leaf-handler-package macrostep macrostep nil)
        (unless
            (package-installed-p 'macrostep)
          (condition-case err
              (progn
                (unless (assoc 'macrostep package-archive-contents)
                  (package-refresh-contents))
                (package-install 'macrostep))
            (error
             (condition-case err
                 (progn
                   (package-refresh-contents)
                   (package-install 'macrostep))
               (error
                (leaf-error "In `macrostep' block, failed to :package of macrostep.  Error msg: %s"
                            (error-message-string err)))))))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org76a24df" class="outline-3">
<h3 id="org76a24df">:feather keyword</h3>
<div class="outline-text-3" id="text-org76a24df">
<p>
<code>:feather</code> keyword provede frontend of <code>feather</code>.
</p>

<p>
Like most <code>:package</code>, but use <code>feather-add-after-installed-hook-sexp</code> to set up an S-exp like <code>:config</code> so that feather expects it.
If a leaf block specifies multiple packages to install, the S-exp is set to execute after the last package is installed.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/feather
    '(
      ;; 't will be converted leaf--name
      ((leaf leaf
         :init (leaf-pre-init)
         :feather t
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (feather-add-after-installed-hook-sexp leaf
           (leaf-pre-init)
           (leaf-init))))

      ;; multi symbols will be accepted
      ((leaf leaf
         :init (leaf-pre-init)
         :feather leaf leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-handler-package leaf leaf-polyfill nil)
         (feather-add-after-installed-hook-sexp leaf-polyfill
           (leaf-pre-init)
           (leaf-init))))

      ;; multi symbols in list will be accepted
      ((leaf leaf
         :feather (feather leaf-key leaf-browser)
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf feather nil)
         (leaf-handler-package leaf leaf-key nil)
         (leaf-handler-package leaf leaf-browser nil)
         (feather-add-after-installed-hook-sexp leaf-browser
           (leaf-init))))

      ;; multi keyword will be accepted
      ((leaf leaf
         :init (leaf-pre-init)
         :feather t
         :feather leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-handler-package leaf leaf-polyfill nil)
         (feather-add-after-installed-hook-sexp leaf-polyfill
           (leaf-pre-init)
           (leaf-init))))

      ;; keywords such as :preface that expand before :feather
      ;; are not registered in the hook of feather
      ((leaf leaf
         :preface (leaf-preface)
         :init (leaf-pre-init)
         :feather t
         :config (leaf-init))
       (prog1 'leaf
         (leaf-preface)
         (leaf-handler-package leaf leaf nil)
         (feather-add-after-installed-hook-sexp leaf
           (leaf-pre-init)
           (leaf-init))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgc26ef3d" class="outline-3">
<h3 id="orgc26ef3d">:el-get keyword</h3>
<div class="outline-text-3" id="text-orgc26ef3d">
<p>
<code>:el-get</code> provide frontend of <code>el-get-bundle</code>.
</p>

<p>
If you specify <code>t</code>, leaf assumes that you specified the name of the leaf-block.
</p>

<p>
Given a list, the arguments are passed as is to the <code>el-get-bundle</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/el-get
    '(((leaf leaf
         :init (leaf-pre-init)
         :el-get t
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get leaf leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get t
         :el-get leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get t leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get (zenburn-theme
                  :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                  (load-theme 'zenburn t))
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle zenburn-theme :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                (load-theme 'zenburn t))))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get
         (yaicomplete
          :url "https://github.com/tarao/elisp.git"
          :features yaicomplete)
         (zenburn-theme
          :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
          (load-theme 'zenburn t))
         (kazu-yamamoto/Mew :name mew :build ("./configure" "make"))
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle yaicomplete :url "https://github.com/tarao/elisp.git" :features yaicomplete)
              (el-get-bundle zenburn-theme :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                (load-theme 'zenburn t))
              (el-get-bundle kazu-yamamoto/Mew :name mew :build ("./configure" "make"))))
         (leaf-pre-init)
         (leaf-init)))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org8dc50f6" class="outline-3">
<h3 id="org8dc50f6">:straight keyword</h3>
<div class="outline-text-3" id="text-org8dc50f6">
<p>
<code>:straight</code> provides a frontend for <code>straight-use-package</code>.
</p>

<p>
If you specify <code>t</code>, leaf assumes that you specified the name of the leaf-block.
</p>

<p>
Given a list, the arguments are passed as is to <code>straight-use-package</code>.
</p>

<div class="org-src-container">
<pre><code class="language-elisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/straight
    '(((leaf leaf
         :init (leaf-pre-init)
         :straight t
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package 'leaf)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :straight leaf leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package 'leaf)
              (straight-use-package 'leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :straight t
         :straight leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package 'leaf)
              (straight-use-package 'leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :straight t leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package 'leaf)
              (straight-use-package 'leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :straight (zenburn-theme :type git :host github :repo "fake/fake")
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package '(zenburn-theme :type git :host github :repo "fake/fake"))))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :straight
         (zenburn-theme :type git :host github :repo "fake/fake")
         (yaicomplete :type git :host github :repo "fake/faker")
         (mew :type git :host gitlab :repo "fake/fakest" :no-build)
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'straight
           '(progn
              (straight-use-package '(zenburn-theme :type git :host github :repo "fake/fake"))
              (straight-use-package '(yaicomplete :type git :host github :repo "fake/faker"))
              (straight-use-package '(mew :type git :host gitlab :repo "fake/fakest" :no-build))))
         (leaf-pre-init)
         (leaf-init)))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgef4bd83" class="outline-3">
<h3 id="orgef4bd83">:ensure-system-package keyword</h3>
<div class="outline-text-3" id="text-orgef4bd83">
<p>
<code>:ensure-system-package</code> provides a frontend for <a href="https://gitlab.com/jabranham/system-packages">system-packages</a>.
</p>

<p>
If you specify <code>t</code>, leaf assumes that you specified the name of the leaf-block.
</p>

<div class="org-src-container">
<pre><code class="language-elisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/ensure-system-package
    '(
      ;; specify a symbol to set to autoload function
      ((leaf leaf
         :ensure-system-package rg
         :config (leaf-init))
       (prog1 'leaf
         (unless (executable-find "rg") (system-packages-install "rg"))
         (leaf-init)))

      ;; multi symbols will be accepted
      ((leaf leaf
         :ensure-system-package rg exa bat)
       (prog1 'leaf
         (unless (executable-find "rg") (system-packages-install "rg"))
         (unless (executable-find "exa") (system-packages-install "exa"))
         (unless (executable-find "bat") (system-packages-install "bat"))))

      ;; multi symbols in list will be accepted
      ((leaf leaf
         :ensure-system-package (rg exa bat))
       (prog1 'leaf
         (unless (executable-find "rg") (system-packages-install "rg"))
         (unless (executable-find "exa") (system-packages-install "exa"))
         (unless (executable-find "bat") (system-packages-install "bat"))))

      ;; It is accepted even if you specify symbol and list at the same time
      ((leaf leaf
         :ensure-system-package openssl (rg exa bat))
       (prog1 'leaf
         (unless (executable-find "openssl") (system-packages-install "openssl"))
         (unless (executable-find "rg") (system-packages-install "rg"))
         (unless (executable-find "exa") (system-packages-install "exa"))
         (unless (executable-find "bat") (system-packages-install "bat"))))

      ;; if you specify t, use leaf--name
      ((leaf rg
         :ensure-system-package t)
       (prog1 'rg
         (unless (executable-find "rg") (system-packages-install "rg"))))

      ;; Specify the package the package name for given symbol
      ((leaf leaf
         :ensure-system-package (rg . ripgrep))
       (prog1 'leaf
         (unless (executable-find "rg") (system-packages-install "ripgrep"))))

      ;; Install package if the presence of file is nil
      ((leaf vterm
         :ensure-system-package (("/usr/lib/libvterm.so" . libvterm)
                                 (cmake libtool)))
       (prog1 'vterm
         (unless (file-exists-p "/usr/lib/libvterm.so") (system-packages-install "libvterm"))
         (unless (executable-find "cmake") (system-packages-install "cmake"))
         (unless (executable-find "libtool") (system-packages-install "libtool"))))

      ;; you can specify install shell command
      ((leaf vterm
         :ensure-system-package (prettier . "npm i -g prettier-plugin-svelte"))
       (prog1 'vterm
         (unless (executable-find "prettier") (async-shell-command "npm i -g prettier-plugin-svelte"))))))
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf307bbd" class="outline-2">
<h2 id="orgf307bbd">Bind keywords</h2>
<div class="outline-text-2" id="text-orgf307bbd">
</div>
<div id="outline-container-orgbc4092e" class="outline-3">
<h3 id="orgbc4092e">:bind :bind* keywords</h3>
<div class="outline-text-3" id="text-orgbc4092e">
<p>
These keywords are buildin. Info is <a href="https://github.com/conao3/leaf.el#bind-bind-keywords">here</a>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/bind
    '(((leaf macrostep
         :package t
         :bind (("C-c e" . macrostep-expand)))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (leaf-keys (("C-c e" . macrostep-expand)))))

      ((leaf macrostep
         :package t
         :bind ("C-c e" . macrostep-expand))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (leaf-keys
          (("C-c e" . macrostep-expand)))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     ("M-o" . isearch-moccur)
                     ("M-O" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                ("M-o" . isearch-moccur)
                ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     ("M-o" . isearch-moccur)
                     ("M-O" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind
         ("M-s" . nil)
         ("M-s o" . isearch-moccur)
         ("M-s i" . isearch-moccur-all))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s")
                     ("M-s o" . isearch-moccur)
                     ("M-s i" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind (("M-s" . nil)
                ("M-s o" . isearch-moccur)
                ("M-s i" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s")
                     ("M-s o" . isearch-moccur)
                     ("M-s i" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         (:isearch-mode-map
          ("M-o" . isearch-moccur)
          ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package color-moccur
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         (:isearch-mode-map
          :package isearch
          ("M-o" . isearch-moccur)
          ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ;; you also use symbol instead of keyword to specify keymap
      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (isearch-mode-map
                 :package isearch
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))))

  (cort-deftest-with-macroexpand leaf/leaf-key
    '(((leaf-key "C-M-i" 'flyspell-correct-wrapper)
       (let* ((old (lookup-key global-map (kbd "C-M-i")))
              (value `(("C-M-i" . global-map) flyspell-correct-wrapper ,(and old (not (numberp old)) old))))
         (push value leaf-key-bindlist)
         (define-key global-map (kbd "C-M-i") 'flyspell-correct-wrapper)))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org620bbc6" class="outline-3">
<h3 id="org620bbc6">:hydra, :mode-hydra, :pretty-hydra keyword</h3>
<div class="outline-text-3" id="text-org620bbc6">
<p>
<code>:hydra</code> provide frontend for <a href="https://github.com/abo-abo/hydra">hydra</a>.
</p>

<p>
If you pass a list, you pass it to <code>defhydra</code>, and if you pass a nested list, you pass each one to it.
</p>

<p>
The reason for using this keyword is that it automatically creates an <code>autoload</code> statement.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/hydra
    '(((leaf face-remap
         :hydra (hydra-zoom
                 (global-map "&lt;f2&gt;")
                 "zoom"
                 ("g" text-scale-increase "in")
                 ("l" text-scale-decrease "out")))
       (prog1 'face-remap
         (autoload #'text-scale-increase "face-remap" nil t)
         (autoload #'text-scale-decrease "face-remap" nil t)
         (eval-after-load 'hydra
           '(progn
              (defhydra hydra-zoom
                (global-map "&lt;f2&gt;")
                "zoom"
                ("g" text-scale-increase "in")
                ("l" text-scale-decrease "out"))))))

      ((leaf yasnippet
         :bind (:yas-minor-mode-map
                ("&lt;f3&gt;" . hydra-yas-primary/body)
                ("&lt;f2&gt;" . hydra-yas/body))
         :hydra ((hydra-yas-primary
                  (:hint nil)
                  "yas-primary"
                  ("i" yas-insert-snippet)
                  ("n" yas-new-snippet)
                  ("v" yas-visit-snippet-file))
                 (hydra-yas
                  (:color blue :hint nil)
                  "
                ^YASnippets^
  --------------------------------------------
    Modes:    Load/Visit:    Actions:

   _g_lobal  _d_irectory    _i_nsert
   _m_inor   _f_ile         _t_ryout
   _e_xtra   _l_ist         _n_ew
           _a_ll
  "
                  ("d" yas-load-directory)
                  ("e" yas-activate-extra-mode)
                  ("i" yas-insert-snippet)
                  ("f" yas-visit-snippet-file :color blue)
                  ("n" yas-new-snippet)
                  ("t" yas-tryout-snippet)
                  ("l" yas-describe-tables)
                  ("g" yas/global-mode)
                  ("m" yas/minor-mode)
                  ("a" yas-reload-all))))
       (prog1 'yasnippet
         (autoload #'yas-insert-snippet "yasnippet" nil t)
         (autoload #'yas-new-snippet "yasnippet" nil t)
         (autoload #'yas-visit-snippet-file "yasnippet" nil t)
         (autoload #'yas-load-directory "yasnippet" nil t)
         (autoload #'yas-activate-extra-mode "yasnippet" nil t)
         (autoload #'yas-tryout-snippet "yasnippet" nil t)
         (autoload #'yas-describe-tables "yasnippet" nil t)
         (autoload #'yas/global-mode "yasnippet" nil t)
         (autoload #'yas/minor-mode "yasnippet" nil t)
         (autoload #'yas-reload-all "yasnippet" nil t)
         (autoload #'hydra-yas-primary/body "yasnippet" nil t)
         (autoload #'hydra-yas/body "yasnippet" nil t)
         (leaf-keys
          ((:yas-minor-mode-map :package yasnippet
                                ("&lt;f3&gt;" . hydra-yas-primary/body)
                                ("&lt;f2&gt;" . hydra-yas/body))))
         (eval-after-load 'hydra
           '(progn
              (defhydra hydra-yas-primary
                (:hint nil)
                "yas-primary"
                ("i" yas-insert-snippet)
                ("n" yas-new-snippet)
                ("v" yas-visit-snippet-file))
              (defhydra hydra-yas
                (:color blue :hint nil)
                "
                ^YASnippets^
  --------------------------------------------
    Modes:    Load/Visit:    Actions:

   _g_lobal  _d_irectory    _i_nsert
   _m_inor   _f_ile         _t_ryout
   _e_xtra   _l_ist         _n_ew
           _a_ll
  "
                ("d" yas-load-directory)
                ("e" yas-activate-extra-mode)
                ("i" yas-insert-snippet)
                ("f" yas-visit-snippet-file :color blue)
                ("n" yas-new-snippet)
                ("t" yas-tryout-snippet)
                ("l" yas-describe-tables)
                ("g" yas/global-mode)
                ("m" yas/minor-mode)
                ("a" yas-reload-all))))))))
</code></pre>
</div>

<p>
And leaf support <a href="https://github.com/jerrypnz/major-mode-hydra.el">major-mode-hydra</a> and <a href="https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra">pretty-hydra</a> via <code>:mode-hydra</code> and <code>:pretty-hydra</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/mode-hydra
    '(
      ;; assume leaf--name as major-mode and no body
      ((leaf go-mode
         :ensure t
         :mode "\\.go\\'"
         :mode-hydra
         ("Doc"
          (("d" godoc-at-point "doc at point"))
          "Imports"
          (("ia" go-import-add "add")
           ("ir" go-remove-unused-imports "cleanup"))))

       (prog1 'go-mode
         (unless (fboundp 'godoc-at-point) (autoload #'godoc-at-point "go-mode" nil t))
         (unless (fboundp 'go-import-add) (autoload #'go-import-add "go-mode" nil t))
         (unless (fboundp 'go-remove-unused-imports) (autoload #'go-remove-unused-imports "go-mode" nil t))
         (unless (fboundp 'go-mode) (autoload #'go-mode "go-mode" nil t))
         (declare-function godoc-at-point "go-mode")
         (declare-function go-import-add "go-mode")
         (declare-function go-remove-unused-imports "go-mode")
         (declare-function go-mode "go-mode")
         (leaf-handler-package go-mode go-mode nil)
         (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
         (major-mode-hydra-define+ go-mode nil
           ("Doc"
            (("d" godoc-at-point "doc at point"))
            "Imports"
            (("ia" go-import-add "add")
             ("ir" go-remove-unused-imports "cleanup"))))))

      ;; assume leaf--name as major-mode and spesific body
      ((leaf go-mode
         :ensure t
         :mode "\\.go\\'"
         :mode-hydra
         ((:title "Go Commands")
          ("Doc"
           (("d" godoc-at-point "doc at point"))
           "Imports"
           (("ia" go-import-add "add")
            ("ir" go-remove-unused-imports "cleanup")))))

       (prog1 'go-mode
         (unless (fboundp 'godoc-at-point) (autoload #'godoc-at-point "go-mode" nil t))
         (unless (fboundp 'go-import-add) (autoload #'go-import-add "go-mode" nil t))
         (unless (fboundp 'go-remove-unused-imports) (autoload #'go-remove-unused-imports "go-mode" nil t))
         (unless (fboundp 'go-mode) (autoload #'go-mode "go-mode" nil t))
         (declare-function godoc-at-point "go-mode")
         (declare-function go-import-add "go-mode")
         (declare-function go-remove-unused-imports "go-mode")
         (declare-function go-mode "go-mode")
         (leaf-handler-package go-mode go-mode nil)
         (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
         (major-mode-hydra-define+ go-mode
           (:title "Go Commands")
           ("Doc"
            (("d" godoc-at-point "doc at point"))
            "Imports"
            (("ia" go-import-add "add")
             ("ir" go-remove-unused-imports "cleanup"))))))

      ;; specify major-mode and body
      ((leaf go-mode
         :ensure t
         :mode "\\.go\\'"
         :mode-hydra
         (go-mode
          (:title "Go Commands")
          ("Doc"
           (("d" godoc-at-point "doc at point"))
           "Imports"
           (("ia" go-import-add "add")
            ("ir" go-remove-unused-imports "cleanup")))))

       (prog1 'go-mode
         (unless (fboundp 'godoc-at-point) (autoload #'godoc-at-point "go-mode" nil t))
         (unless (fboundp 'go-import-add) (autoload #'go-import-add "go-mode" nil t))
         (unless (fboundp 'go-remove-unused-imports) (autoload #'go-remove-unused-imports "go-mode" nil t))
         (unless (fboundp 'go-mode) (autoload #'go-mode "go-mode" nil t))
         (declare-function godoc-at-point "go-mode")
         (declare-function go-import-add "go-mode")
         (declare-function go-remove-unused-imports "go-mode")
         (declare-function go-mode "go-mode")
         (leaf-handler-package go-mode go-mode nil)
         (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
         (major-mode-hydra-define+ go-mode
           (:title "Go Commands")
           ("Doc"
            (("d" godoc-at-point "doc at point"))
            "Imports"
            (("ia" go-import-add "add")
             ("ir" go-remove-unused-imports "cleanup"))))))

      ;; define two or more :mode-hydra at once
      ((leaf elisp-mode
         :mode-hydra
         (emacs-lisp-mode
          (:title "Emacs-lisp Commands")
          ("Eval"
           (("b" eval-buffer "buffer")
            ("e" eval-defun "defun")
            ("r" eval-region "region"))))

         (lisp-interaction-mode
          (:title "Lisp interaction Commands")
          ("Eval"
           (("t" eval-print-last-sexp "this")))))

       (prog1 'elisp-mode
         (unless (fboundp 'eval-buffer) (autoload #'eval-buffer "elisp-mode" nil t))
         (unless (fboundp 'eval-defun) (autoload #'eval-defun "elisp-mode" nil t))
         (unless (fboundp 'eval-region) (autoload #'eval-region "elisp-mode" nil t))
         (unless (fboundp 'eval-print-last-sexp) (autoload #'eval-print-last-sexp "elisp-mode" nil t))
         (declare-function eval-buffer "elisp-mode")
         (declare-function eval-defun "elisp-mode")
         (declare-function eval-region "elisp-mode")
         (declare-function eval-print-last-sexp "elisp-mode")
         (major-mode-hydra-define+ emacs-lisp-mode
           (:title "Emacs-lisp Commands")
           ("Eval"
            (("b" eval-buffer "buffer")
             ("e" eval-defun "defun")
             ("r" eval-region "region"))))
         (major-mode-hydra-define+ lisp-interaction-mode
           (:title "Lisp interaction Commands")
           ("Eval"
            (("t" eval-print-last-sexp "this"))))))))

  (cort-deftest-with-macroexpand leaf/pretty-hydra
    '(
      ;; assume leaf--name as major-mode and no body
      ((leaf go-mode
         :ensure t
         :mode "\\.go\\'"
         :pretty-hydra
         ("Doc"
          (("d" godoc-at-point "doc at point"))
          "Imports"
          (("ia" go-import-add "add")
           ("ir" go-remove-unused-imports "cleanup"))))

       (prog1 'go-mode
         (unless (fboundp 'godoc-at-point) (autoload #'godoc-at-point "go-mode" nil t))
         (unless (fboundp 'go-import-add) (autoload #'go-import-add "go-mode" nil t))
         (unless (fboundp 'go-remove-unused-imports) (autoload #'go-remove-unused-imports "go-mode" nil t))
         (unless (fboundp 'go-mode) (autoload #'go-mode "go-mode" nil t))
         (declare-function godoc-at-point "go-mode")
         (declare-function go-import-add "go-mode")
         (declare-function go-remove-unused-imports "go-mode")
         (declare-function go-mode "go-mode")
         (leaf-handler-package go-mode go-mode nil)
         (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
         (pretty-hydra-define+ go-mode nil
           ("Doc"
            (("d" godoc-at-point "doc at point"))
            "Imports"
            (("ia" go-import-add "add")
             ("ir" go-remove-unused-imports "cleanup"))))))))
</code></pre>
</div>
</div>
</div>



<div id="outline-container-org9e9b615" class="outline-3">
<h3 id="org9e9b615">:transient keyword</h3>
<div class="outline-text-3" id="text-org9e9b615">
<p>
<code>:transient</code> provide frontend for <a href="https://github.com/magit/transient">transient</a>.
</p>

<p>
If you pass a list, you pass it to <code>define-transient-command</code>, and if you pass a nested list, you pass each one to it.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/transient
    '(((leaf dired-git
         :transient
         (transient-dwim-dired-mode--git
          ()
          "Transient-dwim for `dired-mode--git'."
          [["Worktree"
            ("c" "Commit" dired-git-commit)
            ("S" "Stage" dired-git-stage)
            ("U" "Unstage" dired-git-unstage)
            ("zz" "Stash" dired-git-stash)
            ("zp" "Stash pop" dired-git-stash-pop)
            ("X" "Reset --hard" dired-git-reset-hard)]
           ["Branch"
            ("b" "Branch" dired-git-branch)
            ("t" "Tag" dired-git-tag)
            ("f" "Fetch" dired-git-fetch)
            ("F" "Pull" dired-git-pull)
            ("m" "Merge" dired-git-merge)
            ("P" "Push" dired-git-push)
            ("!" "Run" dired-git-run)]]))

       (prog1 'dired-git
         (transient-define-prefix transient-dwim-dired-mode--git ()
           "Transient-dwim for `dired-mode--git'."
           [["Worktree"
             ("c" "Commit" dired-git-commit)
             ("S" "Stage" dired-git-stage)
             ("U" "Unstage" dired-git-unstage)
             ("zz" "Stash" dired-git-stash)
             ("zp" "Stash pop" dired-git-stash-pop)
             ("X" "Reset --hard" dired-git-reset-hard)]
            ["Branch"
             ("b" "Branch" dired-git-branch)
             ("t" "Tag" dired-git-tag)
             ("f" "Fetch" dired-git-fetch)
             ("F" "Pull" dired-git-pull)
             ("m" "Merge" dired-git-merge)
             ("P" "Push" dired-git-push)
             ("!" "Run" dired-git-run)]])))))
</code></pre>
</div>
</div>
</div>
<div id="outline-container-orga47b812" class="outline-3">
<h3 id="orga47b812">:chord :chord* keywords</h3>
<div class="outline-text-3" id="text-orga47b812">
<p>
<code>:chord</code> and <code>:chord*</code> provide frontend for <code>leaf-key-chord</code> which bind key for <a href="https://github.com/emacsorphanage/key-chord">key-chord</a>.
</p>

<p>
The usage and notes are the same as for the <code>:bind</code> keyword.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/chord
    '(((leaf macrostep
         :ensure t
         :chord (("jk" . macrostep-expand)))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . macrostep-expand)))))))

      ((leaf macrostep
         :ensure t
         :chord ("jk" . macrostep-expand))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . macrostep-expand)))))))

      ((leaf color-moccur
         :chord
         ("jk" . moccur)
         ("fi" . isearch-moccur))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord (("jk" . moccur)
                 ("fi" . isearch-moccur)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord
         ("jk" . nil)
         ("fi" . isearch-moccur))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk")
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord (("jk" . nil)
                 ("fi" . isearch-moccur)))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk")
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord
         ("jk" . moccur)
         (:isearch-mode-map
          :package isearch
          ("ji" . isearch-moccur)
          ("jo" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))

      ((leaf color-moccur
         :chord (("jk" . moccur)
                 (:isearch-mode-map
                  :package isearch
                  ("ji" . isearch-moccur)
                  ("jo" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))

      ;; you also use symbol instead of keyword to specify keymap
      ((leaf color-moccur
         :chord (("jk" . moccur)
                 (isearch-mode-map
                  :package isearch
                  ("ji" . isearch-moccur)
                  ("jo" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))))

  (cort-deftest-with-macroexpand leaf/leaf-key-chord
    '(((leaf-key-chord "jj" 'undo 'c-mode-map)
       (leaf-key [key-chord 106 106] 'undo 'c-mode-map))

      ((leaf-key-chord "jk" 'undo 'c-mode-map)
       (progn
         (leaf-key [key-chord 106 107] 'undo 'c-mode-map)
         (leaf-key [key-chord 107 106] 'undo 'c-mode-map)))

      ((leaf-key-chord "jj" 'undo)
       (leaf-key [key-chord 106 106] 'undo nil))

      ((leaf-key-chord "jk" 'undo)
       (progn
         (leaf-key [key-chord 106 107] 'undo nil)
         (leaf-key [key-chord 107 106] 'undo nil)))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org2f3abfa" class="outline-3">
<h3 id="org2f3abfa">:smartrep, :smartrep* keywords</h3>
<div class="outline-text-3" id="text-org2f3abfa">
<p>
<code>:smartrep</code> and <code>:smartrep*</code> provide frontend for <a href="https://github.com/myuhe/smartrep.el">smartrep</a>.
</p>

<p>
They can process a list of arguments that the <code>smartrep</code> accepts, or a nested list of them.
</p>

<p>
Automatically generates an <code>autoload</code> statement when a function symbol is passed.
</p>

<p>
Quoting a function or quoting a binding list works the same way.
</p>

<p>
If you omit the key-map to bind, use <code>global-map</code> instead in <code>:smartrep</code> and
<code>leaf-key-override-global-map</code> for leaf-key in <code>:smartrep*</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/smartrep
    '(((leaf multiple-cursors
         :smartrep ("C-t"
                    (("C-p" . mc/mark-previous-like-this)
                     ("C-n" . mc/mark-next-like-this)
                     ("u"   . mc/unmark-next-like-this)
                     ("U"   . mc/unmark-previous-like-this)
                     ("s"   . mc/skip-to-next-like-this)
                     ("S"   . mc/skip-to-previous-like-this)
                     ("*"   . mc/mark-all-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-all-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)
                  ("u" . mc/unmark-next-like-this)
                  ("U" . mc/unmark-previous-like-this)
                  ("s" . mc/skip-to-next-like-this)
                  ("S" . mc/skip-to-previous-like-this)
                  ("*" . mc/mark-all-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    (("C-p" . mc/mark-previous-like-this)
                     ("C-n" . mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    (("C-p" . 'mc/mark-previous-like-this)
                     ("C-n" . 'mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" quote mc/mark-previous-like-this)
                  ("C-n" quote mc/mark-next-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    '(("C-p" . 'mc/mark-previous-like-this)
                      ("C-n" . 'mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" quote mc/mark-previous-like-this)
                  ("C-n" quote mc/mark-next-like-this)))))))

      ((leaf org
         :smartrep (org-mode-map
                    "C-c"
                    (("C-n" . (outline-next-visible-heading 1))
                     ("C-p" . (outline-previous-visible-heading 1)))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))))))

      ((leaf org
         :smartrep ((org-mode-map
                     "C-c"
                     (("C-n" . (outline-next-visible-heading 1))
                      ("C-p" . (outline-previous-visible-heading 1))))
                    ("s-c"
                     (("M-n" . (outline-next-visible-heading 1))
                      ("M-p" . (outline-previous-visible-heading 1))))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))
              (smartrep-define-key global-map "s-c"
                '(("M-n" outline-next-visible-heading 1)
                  ("M-p" outline-previous-visible-heading 1)))))))))

  (cort-deftest-with-macroexpand leaf/smartrep*
    '(((leaf multiple-cursors
         :smartrep* ("C-t"
                     (("C-p" . mc/mark-previous-like-this)
                      ("C-n" . mc/mark-next-like-this)
                      ("u"   . mc/unmark-next-like-this)
                      ("U"   . mc/unmark-previous-like-this)
                      ("s"   . mc/skip-to-next-like-this)
                      ("S"   . mc/skip-to-previous-like-this)
                      ("*"   . mc/mark-all-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-all-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key leaf-key-override-global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)
                  ("u" . mc/unmark-next-like-this)
                  ("U" . mc/unmark-previous-like-this)
                  ("s" . mc/skip-to-next-like-this)
                  ("S" . mc/skip-to-previous-like-this)
                  ("*" . mc/mark-all-like-this)))))))

      ((leaf org
         :smartrep* ((org-mode-map
                      "C-c"
                      (("C-n" . (outline-next-visible-heading 1))
                       ("C-p" . (outline-previous-visible-heading 1))))
                     ("s-c"
                      (("M-n" . (outline-next-visible-heading 1))
                       ("M-p" . (outline-previous-visible-heading 1))))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))
              (smartrep-define-key leaf-key-override-global-map "s-c"
                '(("M-n" outline-next-visible-heading 1)
                  ("M-p" outline-previous-visible-heading 1)))))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org37d7e1a" class="outline-3">
<h3 id="org37d7e1a">:combo, :combo* keywords</h3>
<div class="outline-text-3" id="text-org37d7e1a">
<p>
<code>:combo</code>, <code>:combo*</code> provide frontend for <a href="https://github.com/uk-ar/key-combo">key-combo</a>.
</p>

<p>
They can process a list of arguments, or a nested list of them.
</p>

<p>
Automatically generates an <code>autoload</code> statement when a function symbol is passed.
</p>

<p>
If you omit the key-map to bind, use <code>global-map</code> instead in <code>:combo</code> and
<code>leaf-key-override-global-map</code> for leaf-key in <code>:combo*</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/key-combo
    '(((leaf key-combo
         :combo (("="   . (" = " " == " " === " ))
                 ("=&gt;"  . " =&gt; ")
                 ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                 ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define global-map "=&gt;" " =&gt; ")
              (key-combo-define global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo (emacs-lisp-mode-map
                 ("="   . (" = " " == " " === " ))
                 ("=&gt;"  . " =&gt; ")
                 ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                 ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define emacs-lisp-mode-map "=" '(" = " " == " " === "))
              (key-combo-define emacs-lisp-mode-map "=&gt;" " =&gt; ")
              (key-combo-define emacs-lisp-mode-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo ((("="   . (" = " " == " " === " ))
                  ("=&gt;"  . " =&gt; ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return)))
                 (emacs-lisp-mode-map
                  ("."  . ("." " . "))
                  ("="  . ("= " "eq " "equal ")))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define global-map "=&gt;" " =&gt; ")
              (key-combo-define global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "." '("." " . "))
              (key-combo-define emacs-lisp-mode-map "=" '("= " "eq " "equal "))))))))

  (cort-deftest-with-macroexpand leaf/key-combo*
    '(((leaf key-combo
         :combo* (("="   . (" = " " == " " === " ))
                  ("=&gt;"  . " =&gt; ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define leaf-key-override-global-map "=&gt;" " =&gt; ")
              (key-combo-define leaf-key-override-global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define leaf-key-override-global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo* (emacs-lisp-mode-map
                  ("="   . (" = " " == " " === " ))
                  ("=&gt;"  . " =&gt; ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define emacs-lisp-mode-map "=" '(" = " " == " " === "))
              (key-combo-define emacs-lisp-mode-map "=&gt;" " =&gt; ")
              (key-combo-define emacs-lisp-mode-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo* ((("="   . (" = " " == " " === " ))
                   ("=&gt;"  . " =&gt; ")
                   ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                   ("C-e" . (move-end-of-line end-of-buffer key-combo-return)))
                  (emacs-lisp-mode-map
                   ("."  . ("." " . "))
                   ("="  . ("= " "eq " "equal ")))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define leaf-key-override-global-map "=&gt;" " =&gt; ")
              (key-combo-define leaf-key-override-global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define leaf-key-override-global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "." '("." " . "))
              (key-combo-define emacs-lisp-mode-map "=" '("= " "eq " "equal "))))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org715ef6b" class="outline-3">
<h3 id="org715ef6b">:mode-hook keyword</h3>
<div class="outline-text-3" id="text-org715ef6b">
<p>
<code>:mode-hook</code> provides a front end for setting hooks.
</p>

<p>
Functions registered in hooks are automatically declared function as names like <code>leaf-keywords-mode-hook--cc-mode--cc-mode-hook</code>.
</p>

<p>
If you write multiple expressions like <code>:config</code>, the hook name is guessed from <code>leaf-name</code> and the function is registered to the guessed hook.
</p>

<p>
To specify the hook name explicitly, specify a hook symbol in <code>car</code> and a list of S expressions in <code>cdr</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/mode-hook
    '((;; you can place sexp(s) like :config
       (leaf cc-mode
         :mode-hook
         (electric-pair-mode 1)
         (delete-selection-mode 1))
       (prog1 'cc-mode
         (leaf-keywords-handler-mode-hook cc-mode cc-mode-hook
           (electric-pair-mode 1)
           (delete-selection-mode 1))))

      (;; you can configure multiple mode hooks
       (leaf cc-mode
         :config
         (setq-default c-basic-offset 8)
         :mode-hook
         (c-mode-common-hook . ((setq-local tab-width 8)))
         (java-mode-hook . ((setq-local tab-width 4)
                            (setq-local c-basic-offset 4))))
       (prog1 'cc-mode
         (leaf-keywords-handler-mode-hook cc-mode c-mode-common-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode java-mode-hook
           (setq-local tab-width 4)
           (setq-local c-basic-offset 4))
         (setq-default c-basic-offset 8)))

      (;; you can apply same sexp to multiple mode hooks
       (leaf cc-mode
         :config
         (setq-default c-basic-offset 8)
         :mode-hook
         (c-mode-common-hook emacs-lisp-mode-hook lisp-mode-hook . ((setq-local tab-width 8)))
         (java-mode-hook . ((setq-local tab-width 4)
                            (setq-local c-basic-offset 4))))
       (prog1 'cc-mode
         (leaf-keywords-handler-mode-hook cc-mode c-mode-common-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode emacs-lisp-mode-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode lisp-mode-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode java-mode-hook
           (setq-local tab-width 4)
           (setq-local c-basic-offset 4))
         (setq-default c-basic-offset 8)))

      (;; you can mix abobe two specification method
       (leaf cc-mode
         :config
         (setq-default c-basic-offset 8)
         :mode-hook
         (setq-local tab-width 8)
         (java-mode-hook . ((setq-local tab-width 4)
                            (setq-local c-basic-offset 4))))
       (prog1 'cc-mode
         (leaf-keywords-handler-mode-hook cc-mode cc-mode-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode java-mode-hook
           (setq-local tab-width 4)
           (setq-local c-basic-offset 4))
         (setq-default c-basic-offset 8)))

      (;; multiple keyword specification is supported
       (leaf cc-mode
         :config
         (setq-default c-basic-offset 8)
         :mode-hook
         (setq-local tab-width 8)
         (c-mode-common-hook . ((setq-local tab-width 8)))
         :mode-hook
         (java-mode-hook . ((setq-local tab-width 4)
                            (setq-local c-basic-offset 4))))
       (prog1 'cc-mode
         (leaf-keywords-handler-mode-hook cc-mode cc-mode-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode c-mode-common-hook
           (setq-local tab-width 8))
         (leaf-keywords-handler-mode-hook cc-mode java-mode-hook
           (setq-local tab-width 4)
           (setq-local c-basic-offset 4))
         (setq-default c-basic-offset 8)))

      (;; leaf-keywords-handler-mode-hook expand like below
       (leaf-keywords-handler-mode-hook cc-mode cc-mode-hook
         (electric-pair-mode 1)
         (delete-selection-mode 1))
       (progn
         (defun leaf-keywords-mode-hook--cc-mode--cc-mode-hook ()
           "Function autogenerated by leaf-keywords in leaf-block `cc-mode' for hook `cc-mode-hook'."
           (electric-pair-mode 1)
           (delete-selection-mode 1))
         (add-hook 'cc-mode-hook 'leaf-keywords-mode-hook--cc-mode--cc-mode-hook)))))
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6d0d37d" class="outline-2">
<h2 id="org6d0d37d">Modeline keywords</h2>
<div class="outline-text-2" id="text-org6d0d37d">
</div>
<div id="outline-container-org9ac8558" class="outline-3">
<h3 id="org9ac8558">:blackout keyword</h3>
<div class="outline-text-3" id="text-org9ac8558">
<p>
<code>:blackout</code> keyword provide frontend for <a href="https://github.com/raxod502/blackout">blackout</a>.
</p>

<p>
There are three packages that change the display of the modeline:
<code>deminish</code>, <code>delight</code> and <code>blackout</code>, but the most recent
developed is <code>blackout</code>, and the developer of <code>leaf</code> recommend
that you use <code>blackout</code>.
</p>

<p>
This package allows you to change the display of the major mode
as well as the minor mode.  And it also requires two arguments,
so it can be set in the cons-cell and has a high affinity with
other keywords in <code>leaf</code>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/blackout
    '(
      ;; t will be converted leaf--name
      ((leaf foo-mode
         :blackout t)
       (prog1 'foo-mode
         (with-eval-after-load 'foo-mode
           (blackout 'foo-mode nil))))

      ;; guess leaf--name as mode-name
      ((leaf foo
         :blackout t)
       (prog1 'foo
         (with-eval-after-load 'foo
           (blackout 'foo-mode nil))))

      ;; blackout if specify symbol only
      ((leaf simple
         :blackout auto-fill-mode)
       (prog1 'simple
         (with-eval-after-load 'simple
           (blackout 'auto-fill-mode nil))))

      ;; expect cons-cell to change display of a mode
      ((leaf simple
         :blackout (auto-fill-mode . " Auto-Fill"))
       (prog1 'simple
         (with-eval-after-load 'simple
           (blackout 'auto-fill-mode " Auto-Fill"))))

      ;; change major-mode display by same way
      ((leaf elisp-mode
         :blackout (emacs-lisp-mode . "Elisp"))
       (prog1 'elisp-mode
         (with-eval-after-load 'elisp-mode
           (blackout 'emacs-lisp-mode "Elisp"))))

      ;; cons-cell list also accepted
      ((leaf simple
         :blackout ((auto-fill-mode . " Auto-Fill")
                    (overwrite-mode . " Overwrite")))
       (prog1 'simple
         (with-eval-after-load 'simple
           (blackout 'auto-fill-mode " Auto-Fill")
           (blackout 'overwrite-mode " Overwrite"))))

      ;; multi cons-cell also accepted
      ((leaf simple
         :blackout
         (auto-fill-mode . " Auto-Fill")
         (overwrite-mode . " Overwrite"))
       (prog1 'simple
         (with-eval-after-load 'simple
           (blackout 'auto-fill-mode " Auto-Fill")
           (blackout 'overwrite-mode " Overwrite"))))

      ;; multi keyword also accepted
      ((leaf simple
         :blackout (auto-fill-mode . " Auto-Fill")
         :blackout (overwrite-mode . " Overwrite"))
       (prog1 'simple
         (with-eval-after-load 'simple
           (blackout 'auto-fill-mode " Auto-Fill")
           (blackout 'overwrite-mode " Overwrite"))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org9487779" class="outline-3">
<h3 id="org9487779">:diminish keyword</h3>
<div class="outline-text-3" id="text-org9487779">
<p>
<code>:diminish</code> keyword provide frontend for <a href="https://github.com/myrjola/diminish.el/tree/master">diminish</a>.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/diminish
    '(((leaf autorevert
         :diminish t)
       (prog1 'autorevert
         (with-eval-after-load 'autorevert
           (diminish 'autorevert-mode nil))))

      ((leaf autorevert
         :diminish autorevert-mode)
       (prog1 'autorevert
         (with-eval-after-load 'autorevert
           (diminish 'autorevert-mode nil))))

      ((leaf autorevert
         :diminish t
         :diminish autorevert-polyfill)
       (prog1 'autorevert
         (with-eval-after-load 'autorevert
           (diminish 'autorevert-mode nil)
           (diminish 'autorevert-polyfill-mode nil))))

      ((leaf autorevert
         :diminish t autorevert-polyfill)
       (prog1 'autorevert
         (with-eval-after-load 'autorevert
           (diminish 'autorevert-mode nil)
           (diminish 'autorevert-polyfill-mode nil))))

      ((leaf go-mode
         :diminish " Go")
       (prog1 'go-mode
         (with-eval-after-load 'go-mode
           (diminish 'go-mode " Go"))))

      ((leaf abbrev
         :diminish (abbrev-mode . " Abv"))
       (prog1 'abbrev
         (with-eval-after-load 'abbrev
           (diminish 'abbrev-mode " Abv"))))

      ((leaf projectile
         :diminish (projectile-mode . '(:eval (concat " " (projectile-project-name)))))
       (prog1 'projectile
         (with-eval-after-load 'projectile
           (diminish 'projectile-mode
                     '(:eval (concat " " (projectile-project-name)))))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgdcd9394" class="outline-3">
<h3 id="orgdcd9394">:delight keyword</h3>
<div class="outline-text-3" id="text-orgdcd9394">
<p>
<code>:delight</code> keyword provide frontend for delight (<a href="http://elpa.gnu.org/packages/delight.html">ELPA</a>, <a href="https://www.emacswiki.org/emacs/DelightedModes">Emacs wiki</a>).
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/delight
    '(((leaf autorevert
         :delight t)
       (prog1 'autorevert
         (delight 'autorevert-mode)))

      ((leaf autorevert
         :delight autorevert)
       (prog1 'autorevert
         (delight 'autorevert-mode)))

      ((leaf autorevert
         :delight t
         :delight autorevert-polyfill)
       (prog1 'autorevert
         (delight 'autorevert-mode)
         (delight 'autorevert-polyfill-mode)))

      ((leaf autorevert
         :delight t autorevert-polyfill)
       (prog1 'autorevert
         (delight 'autorevert-mode)
         (delight 'autorevert-polyfill-mode)))

      ((leaf go-mode
         :delight " Go")
       (prog1 'go-mode
         (delight 'go-mode " Go")))

      ((leaf abbrev
         :delight (abbrev-mode " Abv"))
       (prog1 'abbrev
         (delight 'abbrev-mode " Abv")))

      ((leaf projectile
         :delight (projectile-mode '(:eval (concat " " (projectile-project-name)))))
       (prog1 'projectile
         (delight 'projectile-mode
                  '(:eval
                    (concat " "
                            (projectile-project-name))))))

      ((leaf delight
         :delight ((abbrev-mode " Abv" "abbrev")
                   (smart-tab-mode " \\t" "smart-tab")
                   (eldoc-mode nil "eldoc")
                   (rainbow-mode)
                   (overwrite-mode " Ov" t)
                   (emacs-lisp-mode "Elisp" :major)))
       (prog1 'delight
         (delight 'abbrev-mode " Abv" "abbrev")
         (delight 'smart-tab-mode " \\t" "smart-tab")
         (delight 'eldoc-mode nil "eldoc")
         (delight 'rainbow-mode)
         (delight 'overwrite-mode " Ov" t)
         (delight 'emacs-lisp-mode "Elisp" :major)))))
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8044adb" class="outline-2">
<h2 id="org8044adb">Misc keywords</h2>
<div class="outline-text-2" id="text-org8044adb">
</div>
<div id="outline-container-org26a10c6" class="outline-3">
<h3 id="org26a10c6">:grugru keyword</h3>
<div class="outline-text-3" id="text-org26a10c6">
<p>
<code>:grugru</code> keyword provide frontend for <a href="https://github.com/ROCKTAKEY/grugru">grugru</a>.
</p>

<p>
<code>grugru</code> allows you to define conversion rules for symbols based on
the <code>major-mode</code>.  This <code>:grugru</code> keyword defines a conversion rule
for <code>grugru</code> and, if you omit the measure mode specification, it
assumes that <code>leaf--name</code> is the target <code>major-mode</code>.
</p>

<p>
If <code>leaf--name</code> is not suffixed with <code>-mode</code>, it is automatically
compensated for.  If your intended <code>major-mode</code> does not follow
these rules, you cannot omit target <code>major-mode</code>.
(e.g. <code>c-mode</code> in <code>cc-mode</code>)
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/grugru
    '(
      ;; grugru difinition with :grugru keyword
      ((leaf cc-mode
         :grugru
         (c-mode
          (symbol "true" "false")))
       (prog1 'cc-mode
         (grugru-define-multiple
          (c-mode (symbol "true" "false")))))

      ;; definition list also accepted
      ((leaf cc-mode
         :grugru
         ((c-mode
           (symbol "true" "false"))))
       (prog1 'cc-mode
         (grugru-define-multiple
          (c-mode (symbol "true" "false")))))

      ;; grugru definition with major-mode list
      ((leaf cc-mode
         :grugru
         ((c-mode c++-mode)
          (symbol "true" "false")))
       (prog1 'cc-mode
         (grugru-define-multiple
          ((c-mode c++-mode)
           (symbol "true" "false")))))

      ;; definition list with major-mode list
      ((leaf cc-mode
         :grugru
         (((c-mode c++-mode)
           (symbol "true" "false"))))
       (prog1 'cc-mode
         (grugru-define-multiple
          ((c-mode c++-mode) (symbol "true" "false")))))

      ;; simple listed definition are inferred to be for leaf--name
      ((leaf lisp-mode
         :grugru
         (symbol "nil" "t")
         (emacs-lisp-mode
          (word "add" "remove")))
       (prog1 'lisp-mode
         (grugru-define-multiple
          (lisp-mode (symbol "nil" "t"))
          (emacs-lisp-mode (word "add" "remove")))))

      ;; simple listed definition list are inferred to be for leaf--name
      ((leaf lisp-mode
         :grugru
         ((symbol "nil" "t")
          (emacs-lisp-mode
           (word "add" "remove"))))
       (prog1 'lisp-mode
         (grugru-define-multiple
          (lisp-mode (symbol "nil" "t"))
          (emacs-lisp-mode (word "add" "remove")))))

      ;; assume major-mode name from leaf--name
      ((leaf gnuplot
         :grugru
         ((symbol "sin" "cos" "tan")
          (symbol "log" "log10")))
       (prog1 'gnuplot
         (grugru-define-multiple
          (gnuplot-mode
           (symbol "sin" "cos" "tan"))
          (gnuplot-mode
           (symbol "log" "log10")))))))
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org3351a3b" class="outline-3">
<h3 id="org3351a3b">:defaults keyword</h3>
<div class="outline-text-3" id="text-org3351a3b">
<p>
This is a keyword that calls a dynamically named function.
</p>

<p>
If you define various settings for this function in a separate
file, you may be able to reduce the number of lines in
init.el.  This is a one of use case of this.
</p>

<p>
Also, if you distribute the functions to be used, someone can use
your recommended settings.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (cort-deftest-with-macroexpand leaf/defaults
    '(((leaf helm
         :ensure t
         :defaults t)
       (prog1 'helm
         (leaf-handler-package helm helm nil)
         (leaf-keywords-defaults--leaf/helm)))

      ((leaf helm
         :when nil
         :ensure t
         :defaults t)
       (prog1 'helm
         (when nil
           (leaf-handler-package helm helm nil)
           (leaf-keywords-defaults--leaf/helm))))

      ((leaf helm
         :ensure t
         :defaults conao3)
       (prog1 'helm
         (leaf-handler-package helm helm nil)
         (leaf-keywords-defaults--conao3/helm)))

      ((leaf helm
         :ensure t
         :defaults conao3 garario3)
       (prog1 'helm
         (leaf-handler-package helm helm nil)
         (leaf-keywords-defaults--conao3/helm)
         (leaf-keywords-defaults--garario3/helm)))

      ((leaf helm
         :ensure t
         :defaults conao3
         :defaults garario3)
       (prog1 'helm
         (leaf-handler-package helm helm nil)
         (leaf-keywords-defaults--conao3/helm)
         (leaf-keywords-defaults--garario3/helm)))

      ((leaf helm
         :ensure t
         :defaults nil
         :defaults conao3
         :defaults garario3)
       (prog1 'helm
         (leaf-handler-package helm helm nil)))))
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org95b57a9" class="outline-2">
<h2 id="org95b57a9">Information</h2>
<div class="outline-text-2" id="text-org95b57a9">
</div>
<div id="outline-container-org1963b1c" class="outline-3">
<h3 id="org1963b1c">Donation</h3>
<div class="outline-text-3" id="text-org1963b1c">
<p>
I love OSS and I am dreaming of working on it as <b>full-time</b> job.
</p>

<p>
<b>With your support</b>, I will be able to spend more time at OSS!
</p>


<div id="orge488d84" class="figure">
<p><a href="https://www.patreon.com/conao3"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" alt="become_a_patron_button.png" /></a>
</p>
</div>
</div>
</div>

<div id="outline-container-orga69c6f5" class="outline-3">
<h3 id="orga69c6f5">Community</h3>
<div class="outline-text-3" id="text-orga69c6f5">
<p>
All feedback and suggestions are welcome!
</p>

<p>
You can use github issues, but you can also use <a href="https://join.slack.com/t/conao3-support/shared_invite/enQtNjUzMDMxODcyMjE1LTA4ZGRmOWYwZWE3NmE5NTkyZjk3M2JhYzU2ZmRkMzdiMDdlYTQ0ODMyM2ExOGY0OTkzMzZiMTNmZjJjY2I5NTM">Slack</a>
if you want a more casual conversation.
</p>
</div>
</div>

<div id="outline-container-org576d9e4" class="outline-3">
<h3 id="org576d9e4">Contribution</h3>
<div class="outline-text-3" id="text-org576d9e4">
<p>
We welcome PR!
Travis Cl test <code>leaf-test.el</code> with all Emacs version 24.4 or above.
</p>

<p>
I think that it is difficult to prepare the environment locally,
so I think that it is good to throw PR and test Travis for the time being!
Feel free throw PR!
</p>
</div>

<div id="outline-container-org5fffa03" class="outline-4">
<h4 id="org5fffa03">Define new keywords</h4>
<div class="outline-text-4" id="text-org5fffa03">
<p>
The following script is useful for adding keywords. This is a simplified <code>leaf</code> macro for <code>*scratch*</code>.
</p>

<p>
You first design the list that the normalizer should return and define the keyword processor.
Then trial-and-error builds the normalizer by this script, and by typing <code>C-M-x (eval-defun)</code> at the beginning of <code>defcustom</code>,
it can be overwrite variable and recognized by <code>leaf</code> (At that time the function to specify <code>:set</code> is executed.).
</p>

<p>
Once you have the S-expression expected from <a href="https://github.com/joddie/macrostep">macrostep</a>, let <code>leaf-keywords-test.el</code> define multiple tests
to ensure that they will execute correctly into the future.
</p>

<div class="org-src-container">
<pre><code class="language-lisp match-braces rainbow-braces">  (let ((name 'leaf)
        (args '(;; &lt;&lt; Your new leaf argument &gt;&gt;
                :combo (("="   . (" = " " == " " === " ))
                        ("=&gt;"  . " =&gt; ")
                        ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                        ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))))

    ;; call `leaf'
    (let* ((leaf--autoload)
           ;; omit `leaf-append-defaults' to debug
           (args* (leaf-sort-values-plist
                   (leaf-normalize-plist args 'merge 'eval))))

      ;; call `leaf-process-keywords'
      (let ((name name) (plist args*) (raw args*))
        (let* ((leaf--name    name)
               (leaf--key     (pop plist))
               (leaf--keyname (substring (symbol-name leaf--key) 1))
               (leaf--value   (pop plist))
               (leaf--raw     raw)
               (leaf--rest    plist)
               (leaf--body))
          ;; renew (normalize) leaf--value, save follow expansion in leaf--body
          (setq leaf--value
                (cond

                 ;; &lt;&lt; Your new normalizer &gt;&gt;
                 ((memq leaf--key '(:combo :combo*))
                  (let ((map (if (eq :combo leaf--key) 'global-map 'leaf-key-override-global-map))
                        (val) (fns))
                    (setq val (mapcan
                               (lambda (elm)
                                 (cond
                                  ((and (listp elm)
                                        (listp (car elm))
                                        (listp (caar elm)))
                                   (mapcan
                                    (lambda (el)
                                      (let ((emap  (and (symbolp (car el)) (car el)))   ; el's map
                                            (binds (if (leaf-pairp (car el)) el (cdr el))))
                                        (mapcar
                                         (lambda (el)
                                           (setq fns (append fns (if (listp (cdr el)) (cdr el) `(,(cdr el)))))
                                           `(,(or emap map) ,(car el) ,(if (stringp (cdr el)) (cdr el) `',(cdr el))))
                                         binds)))
                                    elm))
                                  ((listp elm)
                                   (let ((emap  (and (symbolp (car elm)) (car elm)))    ; elm's map
                                         (binds (if (leaf-pairp (car elm)) elm (cdr elm))))
                                     (mapcar
                                      (lambda (el)
                                        (setq fns (append fns (if (listp (cdr el)) (cdr el) `(,(cdr el)))))
                                        `(,(or emap map) ,(car el) ,(if (stringp (cdr el)) (cdr el) `',(cdr el))))
                                      binds)))))
                               leaf--value))
                    `(,val ,(delq nil (mapcar (lambda (elm) (when (symbolp elm) elm)) fns)))))))

          (pp `((:dummy)
                ========== leaf--value
                ,leaf--value
                (:dummy)
                ========== leaf--body
                (progn
                  ,@(eval (plist-get leaf-keywords leaf--key)))
                ))
          nil))))
</code></pre>
</div>

<p>
Note: <code>macrostep</code> return <code>function</code> instead of #', replace it via follow regexp by <code>C-M-% (query-replace-regexp)</code>.
</p>

<blockquote>
<p>
(autoload
         (function \([^ ]*\))
         \([^ ]*\) → (autoload #'\1 \2
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org4a815ea" class="outline-3">
<h3 id="org4a815ea">Migration</h3>
<div class="outline-text-3" id="text-org4a815ea">
</div>
<div id="outline-container-org219a9d5" class="outline-4">
<h4 id="org219a9d5">leaf-keywords v1.0 to v2.0</h4>
<div class="outline-text-4" id="text-org219a9d5">
</div>
<ul class="org-ul">
<li><a id="org3d1bb44"></a>Remove leaf-keywords-after-load<br />
<div class="outline-text-5" id="text-org3d1bb44">
<p>
We also have <code>leaf-keywords-after-require</code>, it's confusing.
Plsease use <code>leaf-keywords-after-require</code>.
</p>
</div>
</li>
<li><a id="org3003e60"></a>Rename leaf-keyowrds-before-load to leaf-keyowrds-before-require<br />
<div class="outline-text-5" id="text-org3003e60">
<p>
We also have <code>leaf-keyowrds-after-require</code>,
we should use <code>leaf-keyowrds-before-require</code> to consistency.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org479ad4b" class="outline-3">
<h3 id="org479ad4b">License</h3>
<div class="outline-text-3" id="text-org479ad4b">
<pre class="example" id="org9f2ccfe">
  General Public License Version 3 (GPLv3)
  Copyright (c) Naoya Yamashita - https://conao3.com
  https://github.com/conao3/leaf-keywords.el/blob/master/LICENSE
</pre>
</div>
</div>

<div id="outline-container-org494a454" class="outline-3">
<h3 id="org494a454">Author</h3>
<div class="outline-text-3" id="text-org494a454">
<ul class="org-ul">
<li>Naoya Yamashita (<a href="https://github.com/conao3">conao3</a>)</li>
</ul>
</div>
</div>

<div id="outline-container-org9c8ff34" class="outline-3">
<h3 id="org9c8ff34">Contributors</h3>
<div class="outline-text-3" id="text-org9c8ff34">
<ul class="org-ul">
<li>Leo Gaskin (<a href="https://github.com/leotaku">leotaku</a>)</li>
<li>Nasy (<a href="https://github.com/nasyxx">Nasy</a>)</li>
</ul>
</div>
</div>

<div id="outline-container-orgce945b5" class="outline-3">
<h3 id="orgce945b5">Special Thanks</h3>
<div class="outline-text-3" id="text-orgce945b5">
<p>
Advice and comments given by <a href="http://emacs-jp.github.io/">Emacs-JP</a>'s forum member has been a great help
in developing <code>leaf-keywords.el</code>.
</p>

<p>
Thank you very much!!
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2019-05-24 Fri 00:00</p>
<p class="author">Author: conao3</p>
<p class="date">Created: 2022-11-14 Mon 10:24</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
